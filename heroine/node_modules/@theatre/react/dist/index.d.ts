/**
 * React bindings for dataverse.
 *
 * @packageDocumentation
 */
import type { IDerivation } from '@theatre/dataverse';
import { val } from '@theatre/dataverse';
/**
 * A React hook that executes the callback function and returns its return value
 * whenever there's a change in the values of the dependency array, or in the
 * derivations that are used within the callback function.
 *
 * @param fn - The callback function
 * @param deps - The dependency array
 * @param debugLabel - The label used by the debugger
 *
 * @remarks
 *
 * A common mistake with `usePrism()` is not including its deps in its dependency array. Let's
 * have an eslint rule to catch that.
 */
export declare function usePrism<T>(fn: () => T, deps: unknown[], debugLabel?: string): T;
export declare const useVal: typeof val;
/**
 * A React hook that returns the value of the derivation that it received as the first argument.
 * It works like an implementation of Dataverse's Ticker, except that it runs the side effects in
 * an order where a component's derivation is guaranteed to run before any of its descendents' derivations.
 *
 * @param der - The derivation
 * @param debugLabel - The label used by the debugger
 *
 * @remarks
 * It looks like this new implementation of useDerivation() manages to:
 * 1. Not over-calculate the derivations
 * 2. Render derivation in ancestor -\> descendent order
 * 3. Not set off React's concurrent mode alarms
 *
 *
 * I'm happy with how little bookkeeping we ended up doing here.
 *
 * ---
 *
 * Notes on the latest implementation:
 *
 * # Remove cold derivation reads
 *
 * Prior to the latest change, the first render of every `useDerivation()` resulted in a cold read of its inner derivation.
 * Cold reads are predictably slow. The reason we'd run cold reads was to comply with react's rule of not running side-effects
 * during render. (Turning a derivation hot is _technically_ a side-effect).
 *
 * However, now that users are animating scenes with hundreds of objects in the same sequence, the lag started to be noticable.
 *
 * This commit changes `useDerivation()` so that it turns its derivation hot before rendering them.
 *
 * # Freshen derivations before render
 *
 * Previously in order to avoid the zombie child problem (https://kaihao.dev/posts/stale-props-and-zombie-children-in-redux)
 * we deferred freshening the derivations to the render phase of components. This meant that if a derivation's dependencies
 * changed, `useDerivation()` would schedule a re-render, regardless of whether that change actually affected the derivation's
 * value. Here is a contrived example:
 *
 * ```ts
 * const num = new Box(1)
 * const isPositiveD = prism(() => num.derivation.getValue() >= 0)
 *
 * const Comp = () => {
 *   return <div>{useDerivation(isPositiveD)}</div>
 * }
 *
 * num.set(2) // would cause Comp to re-render- even though 1 is still a positive number
 * ```
 *
 * We now avoid this problem by freshening the derivation (i.e. calling `der.getValue()`) inside `runQueue()`,
 * and then only causing a re-render if the derivation's value is actually changed.
 *
 * This still avoids the zombie-child problem because `runQueue` reads the derivations in-order of their position in
 * the mounting tree.
 *
 * On the off-chance that one of them still turns out to be a zombile child, `runQueue` will defer that particular
 * `useDerivation()` to be read inside a normal react render phase.
 */
export declare function useDerivation<T>(der: IDerivation<T>, debugLabel?: string): T;
/**
 * This makes sure the prism derivation remains hot as long as the
 * component calling the hook is alive, but it does not
 * return the value of the derivation, and it does not
 * re-render the component if the value of the derivation changes.
 *
 * Use this hook if you plan to read a derivation in a
 * useEffect() call, without the derivation causing your
 * element to re-render.
 */
export declare function usePrismWithoutReRender<T>(fn: () => T, deps: unknown[]): IDerivation<T>;
/**
 * This makes sure the derivation remains hot as long as the
 * component calling the hook is alive, but it does not
 * return the value of the derivation, and it does not
 * re-render the component if the value of the derivation changes.
 */
export declare function useDerivationWithoutReRender<T>(der: IDerivation<T>): IDerivation<T>;
//# sourceMappingURL=index.d.ts.map