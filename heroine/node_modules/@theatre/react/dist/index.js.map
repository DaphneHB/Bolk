{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["/**\n * React bindings for dataverse.\n *\n * @packageDocumentation\n */\n\nimport type {IDerivation} from '@theatre/dataverse'\nimport {Box} from '@theatre/dataverse'\nimport {prism, val} from '@theatre/dataverse'\nimport {findIndex} from 'lodash-es'\nimport queueMicrotask from 'queue-microtask'\nimport {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\nimport {unstable_batchedUpdates} from 'react-dom'\n\ntype $IntentionalAny = any\ntype VoidFn = () => void\n\n/**\n * Enables a few traces and debug points to help identify performance glitches in `@theatre/react`.\n * Look up references to this value to see how to make use of those traces.\n */\nconst TRACE: boolean = false && process.env.NODE_ENV !== 'production'\n\nfunction useForceUpdate(debugLabel?: string) {\n  const [, setTick] = useState(0)\n\n  const update = useCallback(() => {\n    setTick((tick) => tick + 1)\n  }, [])\n\n  return update\n}\n\n/**\n * A React hook that executes the callback function and returns its return value\n * whenever there's a change in the values of the dependency array, or in the\n * derivations that are used within the callback function.\n *\n * @param fn - The callback function\n * @param deps - The dependency array\n * @param debugLabel - The label used by the debugger\n *\n * @remarks\n *\n * A common mistake with `usePrism()` is not including its deps in its dependency array. Let's\n * have an eslint rule to catch that.\n */\nexport function usePrism<T>(\n  fn: () => T,\n  deps: unknown[],\n  debugLabel?: string,\n): T {\n  const fnAsCallback = useCallback(fn, deps)\n  const boxRef = useRef<Box<typeof fn>>(null as $IntentionalAny)\n  if (!boxRef.current) {\n    boxRef.current = new Box(fnAsCallback)\n  } else {\n    boxRef.current.set(fnAsCallback)\n  }\n\n  const derivation = useMemo(\n    () =>\n      prism(() => {\n        const fn = boxRef.current.derivation.getValue()\n        return fn()\n      }),\n    [],\n  )\n\n  return useDerivation(derivation, debugLabel)\n}\n\nexport const useVal: typeof val = (p: $IntentionalAny, debugLabel?: string) => {\n  return usePrism(() => val(p), [p], debugLabel)\n}\n\n/**\n * Each usePrism() call is assigned an `order`. Parents have a smaller\n * order than their children, and so on.\n */\nlet lastOrder = 0\n\n/**\n * A sorted array of derivations that need to be refreshed. The derivations are sorted\n * by their order, which means a parent derivation always gets priority to children\n * and descendents. Ie. we refresh the derivations top to bottom.\n */\nconst queue: QueueItem[] = []\nconst setOfQueuedItems = new Set<QueueItem>()\n\ntype QueueItem<T = unknown> = {\n  order: number\n  /**\n   * runUpdate() is the equivalent of a forceUpdate() call. It would only be called\n   * if the value of the inner derivation has _actually_ changed.\n   */\n  runUpdate: VoidFn\n  /**\n   * Some debugging info that are only present if {@link TRACE} is true\n   */\n  debug?: {\n    /**\n     * The `debugLabel` given to `usePrism()/useDerivation()`\n     */\n    label?: string\n    /**\n     * A trace of the first time the component got rendered\n     */\n    traceOfFirstTimeRender: Error\n    /**\n     * An array of the operations done on/about this useDerivation. This is helpful to trace\n     * why a useDerivation's update was added to the queue and why it re-rendered\n     */\n    history: Array<\n      /**\n       * Item reached its turn in the queue\n       */\n      | `queue reached`\n      /**\n       * Item reached its turn in the queue, and errored (likely something in `prism()` threw an error)\n       */\n      | `queue: der.getValue() errored`\n      /**\n       * The item was added to the queue (may be called multiple times, but will only queue once)\n       */\n      | `queueUpdate()`\n      /**\n       * `cb` in `item.der.changesWithoutValues(cb)` was called\n       */\n      | `changesWithoutValues(cb)`\n      /**\n       * Item was rendered\n       */\n      | `rendered`\n    >\n  }\n  /**\n   * A reference to the derivation\n   */\n  der: IDerivation<T>\n  /**\n   * The last value of this derivation.\n   */\n  lastValue: T\n  /**\n   * Would be set to true if the element hosting the `useDerivation()` was unmounted\n   */\n  unmounted: boolean\n  /**\n   * Adds the `useDerivation` to the update queue\n   */\n  queueUpdate: () => void\n  /**\n   * Untaps from `this.der.changesWithoutValues()`\n   */\n  untap: () => void\n}\n\nlet microtaskIsQueued = false\n\nconst pushToQueue = (item: QueueItem) => {\n  _pushToQueue(item)\n  queueIfNeeded()\n}\n\nconst _pushToQueue = (item: QueueItem) => {\n  if (setOfQueuedItems.has(item)) return\n  setOfQueuedItems.add(item)\n\n  if (queue.length === 0) {\n    queue.push(item)\n  } else {\n    const index = findIndex(\n      queue,\n      (existingItem) => existingItem.order >= item.order,\n    )\n    if (index === -1) {\n      queue.push(item)\n    } else {\n      const right = queue[index]\n      if (right.order > item.order) {\n        queue.splice(index, 0, item)\n      }\n    }\n  }\n}\n\n/**\n * Plucks items from the queue\n */\nconst removeFromQueue = (item: QueueItem) => {\n  if (!setOfQueuedItems.has(item)) return\n  setOfQueuedItems.delete(item)\n\n  const index = findIndex(queue, (o) => o === item)\n  queue.splice(index, 1)\n}\n\nfunction queueIfNeeded() {\n  if (microtaskIsQueued) return\n  microtaskIsQueued = true\n\n  queueMicrotask(() => {\n    unstable_batchedUpdates(function runQueue() {\n      while (queue.length > 0) {\n        const item = queue.shift()!\n        setOfQueuedItems.delete(item)\n\n        let newValue\n        if (TRACE) {\n          item.debug?.history.push(`queue reached`)\n        }\n        try {\n          newValue = item.der.getValue()\n        } catch (error) {\n          if (TRACE) {\n            item.debug?.history.push(`queue: der.getValue() errored`)\n          }\n          console.error(\n            'A `der.getValue()` in `useDerivation(der)` threw an error. ' +\n              \"This may be a zombie child issue, so we're gonna try to get its value again in a normal react render phase.\" +\n              'If you see the same error again, then you either have an error in your prism code, or the deps array in `usePrism(fn, deps)` is missing ' +\n              'a dependency and causing the prism to read stale values.',\n          )\n          console.error(error)\n\n          item.runUpdate()\n\n          continue\n        }\n        if (newValue !== item.lastValue) {\n          item.lastValue = newValue\n          item.runUpdate()\n        }\n      }\n    }, 1)\n\n    microtaskIsQueued = false\n  })\n}\n/**\n * A React hook that returns the value of the derivation that it received as the first argument.\n * It works like an implementation of Dataverse's Ticker, except that it runs the side effects in\n * an order where a component's derivation is guaranteed to run before any of its descendents' derivations.\n *\n * @param der - The derivation\n * @param debugLabel - The label used by the debugger\n *\n * @remarks\n * It looks like this new implementation of useDerivation() manages to:\n * 1. Not over-calculate the derivations\n * 2. Render derivation in ancestor -\\> descendent order\n * 3. Not set off React's concurrent mode alarms\n *\n *\n * I'm happy with how little bookkeeping we ended up doing here.\n *\n * ---\n *\n * Notes on the latest implementation:\n *\n * # Remove cold derivation reads\n *\n * Prior to the latest change, the first render of every `useDerivation()` resulted in a cold read of its inner derivation.\n * Cold reads are predictably slow. The reason we'd run cold reads was to comply with react's rule of not running side-effects\n * during render. (Turning a derivation hot is _technically_ a side-effect).\n *\n * However, now that users are animating scenes with hundreds of objects in the same sequence, the lag started to be noticable.\n *\n * This commit changes `useDerivation()` so that it turns its derivation hot before rendering them.\n *\n * # Freshen derivations before render\n *\n * Previously in order to avoid the zombie child problem (https://kaihao.dev/posts/stale-props-and-zombie-children-in-redux)\n * we deferred freshening the derivations to the render phase of components. This meant that if a derivation's dependencies\n * changed, `useDerivation()` would schedule a re-render, regardless of whether that change actually affected the derivation's\n * value. Here is a contrived example:\n *\n * ```ts\n * const num = new Box(1)\n * const isPositiveD = prism(() => num.derivation.getValue() >= 0)\n *\n * const Comp = () => {\n *   return <div>{useDerivation(isPositiveD)}</div>\n * }\n *\n * num.set(2) // would cause Comp to re-render- even though 1 is still a positive number\n * ```\n *\n * We now avoid this problem by freshening the derivation (i.e. calling `der.getValue()`) inside `runQueue()`,\n * and then only causing a re-render if the derivation's value is actually changed.\n *\n * This still avoids the zombie-child problem because `runQueue` reads the derivations in-order of their position in\n * the mounting tree.\n *\n * On the off-chance that one of them still turns out to be a zombile child, `runQueue` will defer that particular\n * `useDerivation()` to be read inside a normal react render phase.\n */\nexport function useDerivation<T>(der: IDerivation<T>, debugLabel?: string): T {\n  const _forceUpdate = useForceUpdate(debugLabel)\n\n  const ref = useRef<QueueItem<T>>(undefined as $IntentionalAny)\n\n  if (!ref.current) {\n    lastOrder++\n\n    ref.current = {\n      order: lastOrder,\n      runUpdate: () => {\n        if (!ref.current.unmounted) {\n          _forceUpdate()\n        }\n      },\n      der,\n      lastValue: undefined as $IntentionalAny,\n      unmounted: false,\n      queueUpdate: () => {\n        if (TRACE) {\n          ref.current.debug?.history.push(`queueUpdate()`)\n        }\n        pushToQueue(ref.current)\n      },\n      untap: der.changesWithoutValues().tap(() => {\n        if (TRACE) {\n          ref.current.debug!.history.push(`changesWithoutValues(cb)`)\n        }\n        ref.current!.queueUpdate()\n      }),\n    }\n\n    if (TRACE) {\n      ref.current.debug = {\n        label: debugLabel,\n        traceOfFirstTimeRender: new Error(),\n        history: [],\n      }\n    }\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (der !== ref.current.der) {\n      console.error(\n        'Argument `der` in `useDerivation(der)` should not change between renders.',\n      )\n    }\n  }\n\n  useLayoutEffect(() => {\n    return function onUnmount() {\n      ref.current.unmounted = true\n      ref.current.untap()\n      removeFromQueue(ref.current)\n    }\n  }, [])\n\n  // if we're queued but are rendering before our turn, remove us from the queue\n  removeFromQueue(ref.current)\n\n  const newValue = ref.current.der.getValue()\n  ref.current.lastValue = newValue\n\n  if (TRACE) {\n    ref.current.debug?.history.push(`rendered`)\n  }\n\n  return newValue\n}\n\n/**\n * This makes sure the prism derivation remains hot as long as the\n * component calling the hook is alive, but it does not\n * return the value of the derivation, and it does not\n * re-render the component if the value of the derivation changes.\n *\n * Use this hook if you plan to read a derivation in a\n * useEffect() call, without the derivation causing your\n * element to re-render.\n */\nexport function usePrismWithoutReRender<T>(\n  fn: () => T,\n  deps: unknown[],\n): IDerivation<T> {\n  const derivation = useMemo(() => prism(fn), deps)\n\n  return useDerivationWithoutReRender(derivation)\n}\n\n/**\n * This makes sure the derivation remains hot as long as the\n * component calling the hook is alive, but it does not\n * return the value of the derivation, and it does not\n * re-render the component if the value of the derivation changes.\n */\nexport function useDerivationWithoutReRender<T>(\n  der: IDerivation<T>,\n): IDerivation<T> {\n  useEffect(() => {\n    const untap = der.keepHot()\n\n    return () => {\n      untap()\n    }\n  }, [der])\n\n  return der\n}\n"],
  "mappings": "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",
  "names": []
}
