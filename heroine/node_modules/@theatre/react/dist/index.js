var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/index.ts
__export(exports, {
  useDerivation: () => useDerivation,
  useDerivationWithoutReRender: () => useDerivationWithoutReRender,
  usePrism: () => usePrism,
  usePrismWithoutReRender: () => usePrismWithoutReRender,
  useVal: () => useVal
});
var import_dataverse = __toModule(require("@theatre/dataverse"));
var import_dataverse2 = __toModule(require("@theatre/dataverse"));
var import_lodash_es = __toModule(require("lodash-es"));
var import_queue_microtask = __toModule(require("queue-microtask"));
var import_react = __toModule(require("react"));
var import_react_dom = __toModule(require("react-dom"));
var TRACE = false;
function useForceUpdate(debugLabel) {
  const [, setTick] = (0, import_react.useState)(0);
  const update = (0, import_react.useCallback)(() => {
    setTick((tick) => tick + 1);
  }, []);
  return update;
}
function usePrism(fn, deps, debugLabel) {
  const fnAsCallback = (0, import_react.useCallback)(fn, deps);
  const boxRef = (0, import_react.useRef)(null);
  if (!boxRef.current) {
    boxRef.current = new import_dataverse.Box(fnAsCallback);
  } else {
    boxRef.current.set(fnAsCallback);
  }
  const derivation = (0, import_react.useMemo)(() => (0, import_dataverse2.prism)(() => {
    const fn2 = boxRef.current.derivation.getValue();
    return fn2();
  }), []);
  return useDerivation(derivation, debugLabel);
}
var useVal = (p, debugLabel) => {
  return usePrism(() => (0, import_dataverse2.val)(p), [p], debugLabel);
};
var lastOrder = 0;
var queue = [];
var setOfQueuedItems = new Set();
var microtaskIsQueued = false;
var pushToQueue = (item) => {
  _pushToQueue(item);
  queueIfNeeded();
};
var _pushToQueue = (item) => {
  if (setOfQueuedItems.has(item))
    return;
  setOfQueuedItems.add(item);
  if (queue.length === 0) {
    queue.push(item);
  } else {
    const index = (0, import_lodash_es.findIndex)(queue, (existingItem) => existingItem.order >= item.order);
    if (index === -1) {
      queue.push(item);
    } else {
      const right = queue[index];
      if (right.order > item.order) {
        queue.splice(index, 0, item);
      }
    }
  }
};
var removeFromQueue = (item) => {
  if (!setOfQueuedItems.has(item))
    return;
  setOfQueuedItems.delete(item);
  const index = (0, import_lodash_es.findIndex)(queue, (o) => o === item);
  queue.splice(index, 1);
};
function queueIfNeeded() {
  if (microtaskIsQueued)
    return;
  microtaskIsQueued = true;
  (0, import_queue_microtask.default)(() => {
    (0, import_react_dom.unstable_batchedUpdates)(function runQueue() {
      var _a, _b;
      while (queue.length > 0) {
        const item = queue.shift();
        setOfQueuedItems.delete(item);
        let newValue;
        if (TRACE) {
          (_a = item.debug) == null ? void 0 : _a.history.push(`queue reached`);
        }
        try {
          newValue = item.der.getValue();
        } catch (error) {
          if (TRACE) {
            (_b = item.debug) == null ? void 0 : _b.history.push(`queue: der.getValue() errored`);
          }
          console.error("A `der.getValue()` in `useDerivation(der)` threw an error. This may be a zombie child issue, so we're gonna try to get its value again in a normal react render phase.If you see the same error again, then you either have an error in your prism code, or the deps array in `usePrism(fn, deps)` is missing a dependency and causing the prism to read stale values.");
          console.error(error);
          item.runUpdate();
          continue;
        }
        if (newValue !== item.lastValue) {
          item.lastValue = newValue;
          item.runUpdate();
        }
      }
    }, 1);
    microtaskIsQueued = false;
  });
}
function useDerivation(der, debugLabel) {
  var _a;
  const _forceUpdate = useForceUpdate(debugLabel);
  const ref = (0, import_react.useRef)(void 0);
  if (!ref.current) {
    lastOrder++;
    ref.current = {
      order: lastOrder,
      runUpdate: () => {
        if (!ref.current.unmounted) {
          _forceUpdate();
        }
      },
      der,
      lastValue: void 0,
      unmounted: false,
      queueUpdate: () => {
        var _a2;
        if (TRACE) {
          (_a2 = ref.current.debug) == null ? void 0 : _a2.history.push(`queueUpdate()`);
        }
        pushToQueue(ref.current);
      },
      untap: der.changesWithoutValues().tap(() => {
        if (TRACE) {
          ref.current.debug.history.push(`changesWithoutValues(cb)`);
        }
        ref.current.queueUpdate();
      })
    };
    if (TRACE) {
      ref.current.debug = {
        label: debugLabel,
        traceOfFirstTimeRender: new Error(),
        history: []
      };
    }
  }
  if (process.env.NODE_ENV !== "production") {
    if (der !== ref.current.der) {
      console.error("Argument `der` in `useDerivation(der)` should not change between renders.");
    }
  }
  (0, import_react.useLayoutEffect)(() => {
    return function onUnmount() {
      ref.current.unmounted = true;
      ref.current.untap();
      removeFromQueue(ref.current);
    };
  }, []);
  removeFromQueue(ref.current);
  const newValue = ref.current.der.getValue();
  ref.current.lastValue = newValue;
  if (TRACE) {
    (_a = ref.current.debug) == null ? void 0 : _a.history.push(`rendered`);
  }
  return newValue;
}
function usePrismWithoutReRender(fn, deps) {
  const derivation = (0, import_react.useMemo)(() => (0, import_dataverse2.prism)(fn), deps);
  return useDerivationWithoutReRender(derivation);
}
function useDerivationWithoutReRender(der) {
  (0, import_react.useEffect)(() => {
    const untap = der.keepHot();
    return () => {
      untap();
    };
  }, [der]);
  return der;
}
//# sourceMappingURL=index.js.map
